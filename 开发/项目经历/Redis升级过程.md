# Redis升级过程

# 1.  背景

​		微信云平台（投保系统）的数据存储采用mysql+redis的存储方式，redis存储配置信息及保险产品信息，redis存储业务员分享的种子（链接）信息和客户的订单信息。redis部署在2核4G的服务器上，在一次升级之后，业务员分享的种子信息数量暴增（业务员可以直接分享，也可以帮助客户填写再分享）， 导致redis内存报警，未到过期时间的种子和客户订单丢失，因此进行redis部署升级。

# 2. 生产环境问题

## 	2.1.  问题

​		业务员反馈升级之后分享的种子信息丢失和客户订单信息大量丢失。

## 	2.2. 问题分析

​		查看redis库中发现已有100+W条数据，升级前只有40+W数据，初步判断是由于内存中存储了大量数据，导致内存耗尽，触发redis的内存淘汰机制，致使大量未过期的数据被误删。

​		此时涉及到redis的过期策略，redis的过期策略为**定期删除+惰性删除**。	

- **定期删除**：指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key（并非遍历所有key），检查其是否过期，如果过期就删除

- **惰性删除**：当获取某个key的时候，redis会检查一下这个key是否过期了？如果过期了此时就会删除，返回空

  ***

  当定期删除和惰性删除依然会有漏掉的key，此时需要靠**内存淘汰机制**来清理：

- **noeviction**：当内存不足以容纳新写入数据时，新写入操作会报错，没人使用

- **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）

- **allkeys-random**：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，很少使用

- **allkeys-lfu**：当内存不足以容纳新写入数据时，移除使用频率最少的key（4.0增加）

- **volatile-lru**：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）

- **volatile-random**：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key

- **volatile-lfu**：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除使用频率最少的key（4.0增加）

- **volatile-ttl**：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

  ---

  ## 2.3. 结论

  ​	生产环境redis实例采用的是**allkeys-lru**内存淘汰机制，当内存满了之后，会自动删除最近最少使用的key，而此可能还并未到期，所以导致了数据丢失的问题。

  ## 2.4. 解决方式

  ​	**应急处理方式**：写一段程序，实用redis的**scan**命令，遍历redis库中所有的key，主动出发redis的惰性删除。中间有点小插曲，开发同事最初使用的keys *命令，导致了redis实例服务停顿，redis是单线程的，在keys *查完之前都不能响应其他请求。

  ​	**终极解决方式**：有两种方案可选，一是增加redis的cpu和内存，内存足够大时也可以解决此问题；二是升级redis的部署方式为集群模式。考虑到redis以后的扩容问题，采用了redis-cluster集群方案

# 3.  部署方式

##  3.1.  升级前部署方式

​	升级前redis部署方式为Redis Sentinel （主从哨兵模式），主从服务器硬件配置为2核4G。

​	Master仅开启AOF备份，频率每秒备份一次，同时启用BGREWRITEAOF功能。

​	Slave同时开启RDB快照存储和AOF备份，RDB每天晚上定时备份，AOF每秒备份一次，同时启勇BGREWRITEAOF功能。

##  3.2. 升级后部署方式	

​	升级后redis部署方式为Redis Cluster集群，共有6个节点，3个master节点和3个slave界定，服务器依然为2核4G。

​	Master仅开启AOF备份，频率每秒备份一次，同时启用BGREWRITEAOF功能。

​	Slave同时开启RDB快照存储和AOF备份，RDB每天晚上定时备份，AOF每秒备份一次，同时启用BGREWRITEAOF功能。